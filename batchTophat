#!/usr/bin/env perl

=pod

=head1 batchTophat

  takes SIMR Lims directory and send fastq from samples for alignment in parallel using SGE

=head1 SYNOPSIS

  batchTophat [options] 
                 [--directories flowcell_1 flowcell_2...]
                 [--fastq_dirs fastq_dir1 fastq_dir2 ...]
                 [--transcriptome-index aGenome_known_tc_tophat_idx | --GTF GTF/GFF_file]
                 [--bowtie2 aGenome_bowtie2_idx]
                 [-- any extra parameter to pass to tophat]
 Options:
  --help            brief help message
  --man             full documentation

  --paired          if using paired-end reads (***UNDER DEVELOPMENT***)

  --destdir          destination dir to save the results (Def: ~/batchAlignement/aln_timeStamp)
  --sub_selection   smaller list of sample to use
  --exluded         sample to remove from the job

  --cpu             number of CPU per tophat jobs (Def: 4)
  --queue           SGE queue to use (Def: all.q)
  --pe              parallel environement (Def: by_node)
  --email           will send an email when individual qsub submision are terminated

  --dryrun          print the jobs that will be sent to SGE

 Every options names can be abreviated to their smaller unique value (ie: -dir/--directories, -de/--destdir)

=head1 REQUIRED ARGUMENTS

=over 8

=item B<--directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--fastq_dirs>

Path to the location of directories containting fastq files. The files has to end in .fq, .fastq, .fq.gz or .fastq.gz
Multiple diretories can be passed (seperated by space). This can be mixed with LIMS generated directories (see above)


=item B<--bowtie2>

Path to the root of the bowtie2 index. if the shell environment varibale BOWTIE2_TX_INDEXES exists poiting to directory containing the index exits, only the name of prefiex name of the index is required.

=back

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--transcriptome-index | --GTF>

Index name or path to a pre-built transcriptome inded or the location of the GTF file to built the transcriptome index. if the shell environment varibale TOPHAT_TX_INDEXES exists poiting to directory containing the index exits, only the name of prefiex name of the index is required.

=item B<-cpu>

Define the number of CPU to run tophat (in fact, the bowtie2 aligment) and the number of slots per node requested
to the SGE manager. I found that there is no net gain in using the full hyperthreaded cores, on a dual quad-core cpu (8 cpu total),
treal time is same at -cpu 4 or -cpu 8. There is a ~20% increase in real time if two 4 cpu jobs are run concurently on a
8 cpu node, so overall,still a significant increase in performance if two jobs run on the same nodes. This is why, the default
is set at 4 cpu (half the dual core)

=item B<-dryrun>

Prints the jobs that will be run without exuting them

=item B<-email user@email.org>

if specificied, will send an email to user@email.org at the end of each qsub submission

=back

=head1 DESCRIPTION

B<This program> will read the SIMR Lims generated directories of flowcells barcode
in search of a file with the .csv extension (the Sample_Report.csv and other iteration previously used by the lims).
It will then use the sample name (in column 1) and associates the coressponding fastq file(s) (in column 3), one sample 
to many fastq files, even if located accross flowcells (as long as the flowcell directories are passed as argument to --directories). Alternatively, fastq files can be directly passed to the --fastqs option.

Then, the fastq file(s) will be passed to tophat and multiple alignment jobs will be sent to the SGE queue, using a 
parallel environment allowing shared memory (all slot assing to a job has to reside on a single node, look for 
a parallel environment using the B<allocation_rules> = $pe_slots or integers >= then your requested CPU number.

The results will be saved indivually named subdirecories using the sample named inside the TopHat_aln directories.
The --dest-dir can be use to define a location to save the results, otherwise, the ~/batchAligment direcory
will be created and each individual runs saved with the local time of the run as name.

=head1 EXAMPLES

./batchTophat --dir test --bowtie Drosophila_melanogaster.BDGP5.73.min  --trans Drosophila_melanogaster.BDGP5.73.min.tc --dest temp

./batchTophat --dir test --bowtie Drosophila_melanogaster.BDGP5.73.min  --trans Drosophila_melanogaster.BDGP5.73.min.tc --sub C587UAS-CD8GFPmaelVDRC100907-1 C587UAS-CD8GFParmiVDRC16206-3 --dest temp

./batchTophat --dryrun --cpu 4 --bowtie Drosophila_melanogaster.BDGP5.73.min --trans Drosophila_melanogaster.BDGP5.73.min.tc --dir /n/analysis/Si/jsg/MOLNG-150/C0TNYACXX/ /n/analysis/Si/jsg/MOLNG-194/D10KJACXX /n/analysis/Si/jsg/MOLNG-194/C0TD0ACXX/ /n/analysis/Si/jsg/MOLNG-194/C11LJACXX/ -dest ~/aln/Si_memory_analysis

./batchTophat  --bowtie Drosophila_melanogaster.BDGP5.73.min --trans Drosophila_melanogaster.BDGP5.73.min.tc --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor

using a directory containting some fastq files (with extension .fq, .fastq, .fq.gz or .fastq.gz

./batchTophat --bowtie Drosophila_melanogaster.BDGP5.73.min --trans Drosophila_melanogaster.BDGP5.73.min.tc --fastq /n/projects/apa/lepus/mba

=cut

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path remove_tree);
use POSIX qw/strftime/;
use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Spec::Functions;
use File::Temp;

our ($man,$help,$debug,$dryrun,@prog_args);
our (@dirs,$ebwt,$tx_idx,$gtf,$DESTDIR,@sub_select,@excluded,$extra,$email,@fastq_dir,$paired);
our ($cpu,$queue,$pe);

our $aligner = 'tophat';

MAIN:{
  init();
  my %idxJID = create_tophat_idx() if $gtf;  
  testIndex();
  my %res;

  
  getSample2Files(\%res) if @dirs;
  processFastqDirs(\%res) if @fastq_dir;

  qsub_align(\%res,\%idxJID);
  
  print("Results will be found in $DESTDIR\n") unless $dryrun;
  exit 0;
}

sub create_tophat_idx{
  print "Creating the transcript index for TopHat splice site alignments\n"; 
  my ($idx,$tx_idx_d);
  if($tx_idx){
    ($idx,$tx_idx_d) = fileparse($tx_idx);
  } else {
    $tx_idx_d = "tophat_tx_idx";
    ($idx) = fileparse($gtf,'.gtf');
    $tx_idx = "$ENV{PWD}/$tx_idx_d/$idx";
  }
  ### create a little temp fastq file just to fire up tophat
  make_path($tx_idx_d);
  ### create a little temp fastq file just to fire up tophat
  my $fh = File::Temp->new(SUFFIX => ".fastq",UNLINK => 0);
  my $fname = $fh->filename;
  print $fh <DATA>;
  close $fh;
  #system("tophat -G $gtf --transcriptome-index=$tx_idx $ebwt $fname >$tx_idx_d/tx.log 2>&1");
  my %idxJID  = spinQsub({common => "tophat -G $gtf --transcriptome-index=$tx_idx $ebwt $fname >$tx_idx_d/tx.log 2>&1"},'idx');
  my %rmJID = spinQsub({common => "rm -rf $fname tophat_out"},'cleanup',\%idxJID);
}

sub testIndex{
  my $ori_tx_idx = $tx_idx;
  my $ori_ebwt = $ebwt;

  ## Expand tilde to full path, 
  $tx_idx =~ s/~\//$ENV{HOME}/;
  $tx_idx =~ s/~(.+\/)/dirname($ENV{HOME})."\/$1"/e;
  $ebwt =~ s/~\//$ENV{HOME}/;
  $ebwt =~ s/~(.+\/)/dirname($ENV{HOME})."\/$1"/e;
  
  unless (-e "$tx_idx.gff" || $gtf){
    if (exists $ENV{TOPHAT_TX_INDEXES}){
      $ENV{TOPHAT_TX_INDEXES} =~ s/~/$ENV{HOME}/;
      $tx_idx = -e "$ENV{TOPHAT_TX_INDEXES}/$tx_idx.gff" ? 
	"$ENV{TOPHAT_TX_INDEXES}/$tx_idx" : undef;
    } else {
      $tx_idx = undef;
    }
  }
  
  unless (-e "$ebwt.1.bt2"){
    if (exists $ENV{BOWTIE2_INDEXES}){
      $ENV{BOWTIE2_INDEXES} =~ s/~/$ENV{HOME}/;
      $ebwt = -e "$ENV{BOWTIE2_INDEXES}/$ebwt.1.bt2" ? 
	"$ENV{BOWTIE2_INDEXES}/$ebwt" : undef;
    } else {
      $ebwt = undef;
    }
  }
  
  die "Can't find tophat transcript index $ori_tx_idx\n" unless $tx_idx ;
  die "Can't find bowtie2 transcript index $ori_ebwt\n" unless $ebwt;
  
}

sub processFastqDirs {
  my $res_p = shift;
  
  for my $dir (@fastq_dir){
    ### Need to test if $dir is really a dir
    opendir(my $dh, $dir) || die;
    for(readdir $dh) {
      if ($_=~/(.+)_(1|2)_.+\.(fastq|fq)/){
	if ($paired){
	  push @{$res_p->{$1}->{$2}}, "$dir/$_";
	} else {
	  push @{$res_p->{$1}}, "$dir/$_";
	}
      }
    }
    closedir $dh;
  }
}

sub getSample2Files {
  my $res_p = shift;
  
  for my $dir (@dirs){
    $dir = File::Spec->rel2abs($dir);
    
    my ($csv,@rest) = glob "$dir/*.csv";
    die " there is more than one CSV file in $dir->[0]" if @rest;
    
    open FH, $csv;
    my($filename, $dir, $suffix) = fileparse($csv);
    my ($f_i,$s_i,%res);
    while (<FH>){
       chomp;
       my @line = split /,/;
       if($. == 1){
	 ($f_i) = grep{$line[$_] eq 'output'} 0..$#line;
	 ($s_i) = grep{$line[$_] eq 'sample name'} 0..$#line;
	 next;
       }
       $res{$line[$f_i]} = $line[$s_i];
     }
    close FH;
    my @fastq = map{File::Spec->rel2abs($_)} glob "${dir}*[ACGT].fastq.gz";
    #my @fastq = map{File::Spec->rel2abs($_)} glob "${dir}*.fastq.gz";
    
    my %excluded = map{$_,1} @excluded if @excluded;
    
    @fastq = grep{!exists $excluded{$_}} @fastq;
    
    for my $path (@fastq){
      my($file) = fileparse($path);
      
      if (!exists $res{$file}){
        print STDERR "$file is not associated with a sample name\n";
      } else {
        push @{$res_p->{$res{$file}}},$path
      }
    }
  }

  if (@sub_select){
    my %sub = map{$_=>1} @sub_select;
    %{$res_p} = map{$_=>$res_p->{$_}} grep{exists $sub{$_}} keys %{$res_p};
  }
  testForBarcode($res_p);
}

sub testForBarcode{
  my $res_p = shift;
  
  for my $sample (keys %{$res_p}){
    next unless scalar @{$res_p->{$sample}} >1;
    my %s;
    for (@{$res_p->{$sample}}){
      my $barcoded_id = join("_",$sample,(basename($_)=~/_([A,C,G,T]+)\./));
      push @{$s{$barcoded_id}},$_;
    }
    if (scalar(keys %s)>1){
      delete $res_p->{$sample};
      map{$res_p->{$_}=$s{$_}} keys %s;
    }
  }
}

sub qsub_align{
  my $res_p = shift();
  my $idxJID_p = shift();
  my %jobs = createAlnJobs($res_p);
  ## Sending the alignment to the SGE queue
  print ">>> Aligning the fasq files\n>>>>>>>>>>\n\n";
  my %alnJID = spinQsub(\%jobs,'align',$idxJID_p) unless $debug;

  my $bam_dir = "$DESTDIR/bam";
  make_path($bam_dir) unless $dryrun;
  
  symlink("../tophat_aln/$_/accepted_hits.bam","$bam_dir/$_.bam") for keys %jobs;
  
  %jobs = indexBams($res_p,$bam_dir);
  my %idxJID = spinQsub(\%jobs,'index',\%alnJID) unless $debug;
}

sub indexBams {
  my %res = %{shift()};
  my $bam_dir = shift;
  my %jobs = map{($_,"samtools index $bam_dir/$_.bam")} keys %res;
  return %jobs;
}

sub createAlnJobs {
  my %res = %{shift()};
  
  my %jobs;
  for my $exp (keys %res){
    my $res_dir = "$DESTDIR/tophat_aln/$exp";
    make_path($res_dir) unless $dryrun;
    
    my $align = "tophat";
    $align   .= " -p$cpu";
    $align   .= " --transcriptome-index=$tx_idx" if $tx_idx;
    $align   .= " -o $res_dir";
    $align   .= " --no-coverage-search";
    $align   .= " $extra";
    $align   .= " $ebwt";
    
    if ($paired){
      $align .= " ".join(",",@{$res{$exp}->{1}})." ".join(",",@{$res{$exp}->{2}});;
    } else {
      $align   .= " ".join(",",@{$res{$exp}});
    }
    
    $jobs{$exp} = $align;
  }
  return(%jobs)
}

sub spinQsub {
  my %jobs = %{shift()};
  my $type = shift();
  my %holders = %{shift()} if @_;
  
  $type ||= '';
    
  
  my $sge_out = "$DESTDIR/SGE_out";
  make_path($sge_out) unless $dryrun;
  
  my (%job_ids,$i);
  for my $exp (keys %jobs){
    
    
    my $com = "qsub";
    $com   .= " -hold_jid ".join(",",(keys %holders)[0] eq 'common'?map{@{$_}} values(%holders):@{$holders{$exp}})
      if exists($holders{$exp}) || exists($holders{common});
    $com   .= " -m e -M $email" if $email;
    $com   .= " -l mem_free=1G";
    $com   .= " -j y -o $sge_out";
    $com   .= " -pe $pe $cpu";
    $com   .= " -q $queue";
    $com   .= " -N ${type}_$exp";
    $com   .= " -V";
    $com   .= " -cwd";
    $com   .= " -terse";
    $com   .= " -b y";
    $com   .= " '$jobs{$exp}'";
    
    print "$com\n";
    print "============>>>\n";
    
    next if $dryrun;
    
    open my $qsub,"-|",$com;
    while (<$qsub>){chomp;push @{$job_ids{$exp}},$_};
    close $qsub;
  }
  
  return(%job_ids);
  
}

sub init {
  my $filename = basename($0);
  @prog_args = ($filename,@ARGV);
  print("Running as:\n",
	join(" ",@prog_args),"\n",
	">>>>>>\n\n"
       );

  GetOptions('debug'                 => \$debug,
	     'help|?'                => \$help,
	     'man'                   => \$man,
	     
	     'directories=s{,}'      => \@dirs,
	     'bowtie2=s'             => \$ebwt,
	     'transcriptome-index=s' => \$tx_idx,
	     'GTF=s'                 => \$gtf,
	     'destdir=s'             => \$DESTDIR,
	     'fastq_dirs=s{,}'       => \@fastq_dir,	     
	     
	     'paired'                => \$paired,

	     'excluded=s{,}'         => \@excluded,
	     'sub_selection=s{,}'    => \@sub_select,
	     
	     'cpu=i'                 => \$cpu,
	     'queue=s'               => \$queue,
	     'pe=s'                  => \$pe,
	     'email=s'               => \$email,
	     'dryrun'                => \$dryrun
	    ) or pod2usage(1);

  if ($help || !((@dirs||@fastq_dir) && $ebwt)){
    pod2usage(-exitstatus => 0, -verbose => 2);
  }elsif ($man){
    pod2usage(-exitstatus => 0, -verbose => 0);
  }

  $cpu     ||= 4;
  $queue   ||= 'all.q';
  $pe      ||= 'by_node';
  $extra = join(' ',@ARGV);
  
  $DESTDIR ||= strftime('bowtieBatch_%Y-%m-%d_%H%M%S',localtime);
  make_path($DESTDIR) unless (-e $DESTDIR && -d $DESTDIR) || $dryrun;
  
  print STDERR "##########RUNNING IN DEBUGING MODE##########\n" if $debug;
}
__DATA__
@ILLUMINA-C4D679_0026_FC:3:1:11884:1072#0/1
CTCGGGTATACATCAAGTGATGGATTATGCAAATTTTGGG
+ILLUMINA-C4D679_0026_FC:3:1:11884:1072#0/1
f[dfdd`\Jcfffff]cOdc^ad[IcdaJdfadfffff]a
@ILLUMINA-C4D679_0026_FC:3:1:16648:1081#0/1
GGACATCTACAAGCCAGTTGACAAAGTCGAACCCGGTACC
+ILLUMINA-C4D679_0026_FC:3:1:16648:1081#0/1
acfbfffc^fYc_ffdf]cfffcfc[bSKcaaadKS^ccc
@ILLUMINA-C4D679_0026_FC:3:1:9324:1106#0/1
CAGCAGTACCAATAACTCCAATAATATGAAGGATCAAGTC
+ILLUMINA-C4D679_0026_FC:3:1:9324:1106#0/1
f_fggfggYggcgagfdggdgdcggaf^[addfffcffRd
@ILLUMINA-C4D679_0026_FC:3:1:10004:1101#0/1
TCGAAAGATGAAAAGAACTTTGAAAAGAGAGTTAAATAGT
+ILLUMINA-C4D679_0026_FC:3:1:10004:1101#0/1
gfcagg_d^ggg_g^f`cda\dffcaa_S\afaead\YYW

